import java.util.*;

class Solution {
    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {
        
        Arrays.sort(meetings, (a, b) -> a[2] - b[2]);

        
        Set<Integer> secret = new HashSet<>();
        secret.add(0);
        secret.add(firstPerson);

        // Union-Find structures (used per time group)
        Map<Integer, Integer> parent = new HashMap<>();

        
        java.util.function.IntUnaryOperator find = new java.util.function.IntUnaryOperator() {
            @Override
            public int applyAsInt(int x) {
                if (parent.get(x) != x) {
                    parent.put(x, applyAsInt(parent.get(x)));
                }
                return parent.get(x);
            }
        };

        int i = 0;
        while (i < meetings.length) {
            int time = meetings[i][2];
            List<int[]> group = new ArrayList<>();

            // Collect all meetings at the same time
            while (i < meetings.length && meetings[i][2] == time) {
                int x = meetings[i][0];
                int y = meetings[i][1];
                group.add(new int[]{x, y});
                parent.put(x, x);
                parent.put(y, y);
                i++;
            }

            // Union all meetings at this time
            for (int[] g : group) {
                int px = find.applyAsInt(g[0]);
                int py = find.applyAsInt(g[1]);
                if (px != py) {
                    parent.put(py, px);
                }
            }

            // Find which components already know the secret
            Set<Integer> compHasSecret = new HashSet<>();
            for (int p : parent.keySet()) {
                if (secret.contains(p)) {
                    compHasSecret.add(find.applyAsInt(p));
                }
            }

            // Spread the secret within those components
            for (int p : parent.keySet()) {
                if (compHasSecret.contains(find.applyAsInt(p))) {
                    secret.add(p);
                }
            }

            // Reset for next time group
            parent.clear();
        }

        return new ArrayList<>(secret);
    }
}
